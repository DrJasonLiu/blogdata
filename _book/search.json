[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data science of JasonLiu",
    "section": "",
    "text": "This is my personal website, or … A book"
  },
  {
    "objectID": "R语言编程-基于tidyverse.html",
    "href": "R语言编程-基于tidyverse.html",
    "title": "R语言编程-基于tidyverse",
    "section": "",
    "text": "Basic grammar of R datascience\n更新R可以用installr包里的updateR函数\n\n> identical(0,1)#判断两个对象是否严格相等\n>"
  },
  {
    "objectID": "R语言编程-基于tidyverse.html#rmarkdown",
    "href": "R语言编程-基于tidyverse.html#rmarkdown",
    "title": "R语言编程-基于tidyverse",
    "section": "Rmarkdown",
    "text": "Rmarkdown\n\n行内代码的使用：可有助于生成可重复性报告。\n#r f(x)#即为行内代码(#换为`)\n行间代码块的设置: 参考网站:https://yihui.org/knitr/options/\neval=F是指定不运行代码块，ecol=F表示不显示代码，但是显示代码的结果，如文本或图片等；include=F指代码会运行，但是代码和结果都不生成到输出的文档中。echo控制代码是否显示，echo=F表示代码框不显示在输出的文档中。如果一个代码块内有多个输出结果，会分解成多个块输出;collapse=T，可以将所有输出结果都集中到一个块里, ’hide’表示不显示结果。prompt=T可以在代码前面加一个>。再加上results=‘hold’的话可以将代码放一起，输出结果放一起。warning=F使代码警告信息不进入结果，可以屏蔽一些扩展包的载入信息；error=F则屏蔽错误信息；如果想全文设置，则可以在开头用knitr来设置。code-fold: true可以将代码折叠起来，只展示结果\n图形输出\nfig.show:设置图片的输出方式\n\nfig.show=‘asis’：表示plot在产生他们的代码后面\nfig.show=‘hold’：表示代码产生的图片都放在一个完整的代码块之后\nfig.show=‘animate’：表示将所有生成的图片合成一个动画图片\nfig.show=‘hide’：表示产生图片，但不显示\n\nfig.width: 设置图片输出宽度\nfig.height：设置图片输出的高度\nfig.align：排版，默认left，可以right或center\nfig.cap：设置图片的标题\nfig.subcap：设置图片的副标题\nout.width=‘50%’：指输出的图片自适应大小为50%\n表格输出\n\n\nCode\n> x <- 1:10;y <- x^2;\n> lmr <- lm(y~x)\n> co <- summary(lmr)$coefficients\n> print(co)\n\n\n\n\n> knitr::kable(co,digits = 2,align = \"c\") #可以将数据输出为单独的表格形式\n\n\n\n\n\nEstimate\nStd. Error\nt value\nPr(>|t|)\n\n\n\n\n(Intercept)\n-22\n5.55\n-3.96\n0\n\n\nx\n11\n0.89\n12.30\n0\n\n\n\n\n\n\n表格渲染\n使用kableExtra包,column_spec和row_spec是设置行和列，kable_styling设置表格格式\nfull_width: 表格宽度是否填满HTML，position：对齐方式，\n\n> library(kableExtra)\n> library(knitr)\n> table_style <- knitr::kable(co,digits = 2,align = \"c\")\n> kableExtra::kable_styling(table_style,full_width = F,position = \"center\") %>% \n+   column_spec(1:2,bold = T,color='black',background = 'lightblue')\n\n\n\n \n  \n      \n    Estimate \n    Std. Error \n    t value \n    Pr(>|t|) \n  \n \n\n  \n    (Intercept) \n    -22 \n    5.55 \n    -3.96 \n    0 \n  \n  \n    x \n    11 \n    0.89 \n    12.30 \n    0 \n  \n\n\n\n\n\n\n\n\n\n\n\n\nTip With Caption\n\n\n\n这是一个callout"
  },
  {
    "objectID": "R机器学习.html",
    "href": "R机器学习.html",
    "title": "R 机器学习",
    "section": "",
    "text": "Programming…"
  },
  {
    "objectID": "R数据可视化.html",
    "href": "R数据可视化.html",
    "title": "R数据可视化",
    "section": "",
    "text": "rayshader包可以将2D图像绘制为3D，基于ggplot2\n\n\nlibrary(rayshader)\nlibrary(ggplot2)\n\n# 绘制二维密度图\ngg = ggplot(diamonds, aes(x, depth)) +\n     stat_density_2d(aes(fill = stat(nlevel)), #绘制密度等高线图\n                  geom = \"polygon\",\n                  n = 100,bins = 10, contour = TRUE) +\n     facet_wrap(clarity~.) +    # 按clarity分类\n     scale_fill_viridis_c(option = \"A\") #将map颜色设置为“岩浆”色，简称为“A”，共有“A”，“B”，“C”，“D”和“E”五种；\nplot_gg(gg,multicore=TRUE,width=5,height=5,scale=250) #转为3D图片\nSys.sleep(0.5)\nrender_snapshot(clear=TRUE)#保存图片"
  },
  {
    "objectID": "nhanesR.html",
    "href": "nhanesR.html",
    "title": "nhanesR",
    "section": "",
    "text": "> library(devtools)\n> library(nhanesR)\n> devtools::install_github('yikeshu0611/nhshelp',force=TRUE)\n> nhshelp::install_nhanesR('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') #安装nhanesR\n> config_path(\"/Users/liulinhu/Desktop/NHANES/2022-08-01/NHANES\")#配置数据库路径\n> config_years()#配置数据库年份\n> config_items()#配置数据库文件类型\n> bu( x,'( 1, 2]')#指(1,2], 即x大于1，≤2\n> bu( x,'[ , ]')#指大于等于，小于等于\n\nfped数据是Food Patterns Equivalents Database，codebook文件里是全部变量的变量和解释；varLabel是标签的解释。"
  },
  {
    "objectID": "nhanesR.html#数据读取",
    "href": "nhanesR.html#数据读取",
    "title": "nhanesR",
    "section": "数据读取",
    "text": "数据读取\n\n知道变量名以及所在的文件: 例如age的变量名是ridageyr，所在的文件是demo_b，demo_c等。\n从文件中提取变量\n\n\n> library(nhanesR)\n> nhs_tsv('demo',years = 2015:2016)#选择2015-2016年的包含demo的数据（demographic）\n> nhs_tsv(\"demo\\\\.\",'!~p',years = 1999)#1999年，包含\"demo.\"但不包含\"p\"的数据\n> \n\n\n> library(nhanesR)\n> tsv <- nhs_tsv(\"demo\")#提取所有人口学数据\n> nhs_brief(tsv,\"age\") |> View() #查找tsv中包含age的所有，从而确定年龄变量名为ridageyr\n> \n> x <- nhs_read(tsv,\"ridageyr:age\",\n+               \"riagendr:gender-u\",\n+               \"dmqmilit:mili\",\n+               \"dmqmiliz:mili\",\n+               codebook = T,)#:后面可以重命名变量;codebook参数表示是否解码变量的含义;如果对某个变量不想解码就在最后加-u;varLebel会给变量加上解释(不建议添加，会改变对象格式)\n> \n> nhs_brief(tsv,\"mili\")#查找参军相关的变量，发现在后面的年份出现了新的变量名dmqmilit和dmqmiliz，其实是一样的,都改为mili变量。该函数运行完后会直接复制变量名到粘贴板，直接在nhs_read中粘贴就可以了\n\n\n强化nhs_tsv()函数对数据的提取\n\n在R中，.表示任意一个字符，\\.则表示单纯的.这个字符。|表示”或者”的逻辑关系, !~表示不包含\n\n> nhs_tsv('lab10')\n> nhs_tsv(\"lab10\\\\.\")#只提取lab10.这个文件\n> \n> nhs_tsv(\"lab13am|l13am|trigly\")#提取这三个文件\n> nhs_tsv(\"lab13am|l13am|trigly\",\"!~l13am_b|l13am_c\")#提取三个文件，但不包含l13am_b和l13am_c\n\n\n实验室检查数据的读取\n先去网站上检索，如hemoglobin，然后确定文件名. nhs_read支持连续添加数据，只需要先输入文件名再输入变量，如(cbc, “lbxhgb’, demo,” riagendr”), 如果不指定变量，会把cbc中所有的变量全部提取进去\n\n> library(nhanesR)\n> demo <- nhs_tsv(\"demo\")#提取所有人口学数据\n> \n> cbc <- nhs_tsv(\"lab25|l25|cbc\")#血红蛋白有三个不同的文件名，全部提取\n> bmx <- nhs_tsv(\"bmx\")#提取bmi和腰围所在的文件\n> \n> x <- nhs_read(demo,\"ridageyr:age\",\"riagendr:gender\",\"dmqmilit:mili\",\"dmqmiliz:mili\",\n+               cbc,\"lbxhgb:Hbg\",\n+               bmx,\"bmxbmi:BMI\",\"bmxwaist:Waist\",\n+               codebook = T)#直接将血红蛋白和BMI和腰围的数据添加到之前人口学数据之后\n> nit1 <- head(x)"
  },
  {
    "objectID": "nhanesR.html#权重",
    "href": "nhanesR.html#权重",
    "title": "nhanesR",
    "section": "权重",
    "text": "权重\n1.找到合理的权重。2.计算合并权重；权重不需要计算，nhanes已经计算好了，只需要计算合并权重。\nNHANES中提供了各种各样的权重，如interview权重(wtint2yr), mec测试权重(wtmec2yr)和一些亚组的权重。一个好的经验法则是使用”最小公分母”，其中针对最少数量的访谈者收集的感兴趣变量是”最小公分母”。适用于该变量的样本权重是用于该特定分析的适当权重。所有访谈和mec测试权重都可以在相应调查周期的人口统计文件中找到。注意：有些问卷组件是在mec会话期间而非家庭访谈期间管理的，因此必须对这些组件使用mec测试权重\n\n如何计算合并权重\nwtint2yr指两年的（一个year circle）权重，选择了几个year circle就乘以几分之1。及合并权重=对应权重*1/n。但当同时涉及到1999-2000和2001-2002时需要用4年权重wtint4yr，分开使用只需要2年权重。如果涉及1999-2002和其他year circle，如2003-2004，此时6年的权重wt6yr=2/3×wt4yr，和1/3×wt2yr。如果是8年权重wt8yr=2/4×wt4yr和1/4×wt2yr，如此类推\n\n\n示例实操\n\n示例1\nnhanes2013-2016，种族西班牙裔血统以及贫困与20岁及以上成年人先前诊断为糖尿病的关联。所有的变量都是在家庭访谈中收集的。使用访谈权重进行分析wtint4yr,查询到种族的变量名为ridreth1，贫困poverty的变量名为indfmpir，年龄变量名为ridageyr；糖尿病的诊断在Questionnaire里的diq010变量。权重提取wtint2yr\n\n\n\n权重总结\n\n家庭采访权重interview（范围最大）；wtint2yr/wtint4yr\n车里的权重MEC（mobile examination car）（范围较int小）；wtmec2yr/wtmec4yr\n其他权重（范围最小）；wtsaf2yr等，范围最小\n选择权重应该选择最小权重，即不同权重的交集（即有特殊权重就选特殊权重，没有就选mec或int\n合并权重的计算：year circle为n，合并权重为1/n*2yr; 如果同时出现1999-2000和2001-2002，这两个circle的合并权重为2/n×4yr，其余的circle还是1/n×2yr"
  },
  {
    "objectID": "nhanesR.html#数据的清洗",
    "href": "nhanesR.html#数据的清洗",
    "title": "nhanesR",
    "section": "数据的清洗",
    "text": "数据的清洗\n\n如何快速输入Factor\n基于nhanesR包里的Factor函数，可以直接生成factor化的代码\n\n\n> c <- c(\"white\",\"black\",\"red\",\"purple\")\n> Factor(c)#运行这行便会自动生成下一行的因子化的代码\n> c <- factor(c, levels = c(\"white\",\"black\",\"red\",\"purple\"))\n\n\n如何修改变量名（Recode）\n\n\n> c <- c(\"white\",\"black\",\"red\",\"purple\")\n> Recode(c)#运行这行便会生成下面的代码，用于将原有的变量改名\n> c.new <- Recode(c,\n+   \"white::\", \n+   \"black::\", \n+   \"red::\", \n+   \"purple::\",\n+   to.numeric = FALSE)\n\n\nNHSIII的数据如何计算合并权重 NHSIII是1999年以前的数据，是以3年为一个周期。计算权重时需要以年来，而不是year circle。例如1994-1996，2001-2002，2009-2010，此时总共3+2+2=7年，所以1994-1996的权重是3/7×wt3yr，其余的是2/7×wt2yr。但是如何同时涉及到1999和2001时，这两个year circle要合并算作4年，用wt4yr来计算。\n选择行和列\n可以用nhanesR里的select_row函数来选择行,drop_row来删除行\n\n\n> d0 <- db_demo(years = 1999:2003,ageyr = \"age\",sex = T,eth1 = T,Year = T,poverty = T)#直接提取1999-2003的所有人口学数据，指定需要出现的列\n> d1 <- select_row(x,x$Year==\"1999-2000\" & x$age >= 50)#选择x中年份为1999-2000，年龄大于等于50岁的数据行\n> d1 <- select_row(x,x$Year %in% c(\"1999-2000\",\"2001-2002\"))#同时设置多个筛选条件\n> d2 <- drop_row(x,x$Year==\"2001-2002\")#去除x中年份为2001-2002的数据\n> d3 <- drop_row(d0,is.na(d0$poverty))#用drop_row也可以去除缺失值\n\n\n数据的合并\n第一种方法是直接用管道操作符添加数据\n\n> d1 <- db_demo(years = c(1999:2003,2007),Year = T,\n+               sex = T,ageyr = \"age\") |> \n+   db_cbc(wbc_1000cells.ul = \"wbc\") |> \n+   dex_phenoAge()\n> #cbc是全血细胞数据，phenoAge是生物学年龄，直接用管道操作符即可不断添加数据\n> head(d1)\n\n\n第二种方法是先分别提取数据，然后再合并.此时可以left_join,righ_join,inner_join,full_join\n\n> d1 <- db_demo(years = c(1999:2003,2007),Year = T,\n+               sex = T,ageyr = \"age\")\n> d2 <- db_cbc(years = c(1999:2003,2007),wbc_1000cells.ul = \"wbc\")\n> d3 <- dex_phenoAge()\n> d4 <- Left_Join(d1,d2,d3)#left_join只匹配d1的序号,可以看到d4和d1具有同样的行数\n> d5 <- Right_Join(d1,d2,d3)#先与d2合并，再与d3合并，最终数据以d3为准\n> d6 <- Inner_Join(d1,d2,d3)#以三者共有的数据为准进行合并\n> d7 <- Full_Join(d1,d2,d3)#所有的数据一起合并\n> \n> d8 <- Left_Join(d2,d1) #会显示d1人口学数据中有4028人没有白细胞计数的数据，便于画流程图\n> # d2   :37247 ; d1:41275(-4028) \n> d8 <- Left_Join(d2,d1,inspect = c(\"age\",\"sex\")) #可以查看某个变量在d1合并到d2前后的变化，绿色表示减少，红色表示增多\n> #其他类型的join也可以inspect\n\n\n\n\n添加新列\n1.添加新列的主要作用为对原始数据的某些值进行判断，增加一些新的变量，例如是否是老年，某些指标是否升高等。\n\n> d <- db_demo(years = 1999,ageyr = \"age\",sex = T,Year = T) |> \n+   db_cbc(wbc_1000cells.ul = \"wbc\")\n> d <- drop_row(d,is.na(d$wbc))#去除白细胞计数的缺失值\n> ####以10为界值，判断白细胞数是否升高####\n> d <- add_col(d,colname = \"wbc_level\",value = \"yes\",condition = d$wbc > 10) |> \n+   add_col(colname = \"wbc_level\",value = \"no\",condition = d$wbc <= 10)#新增一列，列名为wbc_level，白细胞大于10的时候为yes，小于等于10的时候为no\n> \n> ####对于白细胞，男性的界限为10，女性的界限是9####\n> ck <- (d$sex == \"Male\" & d$wbc > 10) | (d$sex == \"Female\" & d$wbc >10)\n> \n> d1 <- add_col(d,colname = \"wbc_level\",value = \"yes\",condition = ck) |> \n+   add_col(colname = \"wbc_level\",value = \"no\",condition = is.na(d1$wbc_level),\n+           position = 2)\n> #先把男性和女性的yes指定了，然后剩下的NA全部是no。position可以指定新增的列的位置\n\n2.也可以用于一些疾病的诊断的添加，例如睡眠呼吸暂停综合征👇\n\n> d <- db_slq(years = 2005,\n+             sleep_disorder_sleep_apnea = \"apnea\",\n+             how_often_do_you_snort_or_stop_breathing = \"stop_breathing\",\n+             how_often_feel_overly_sleepy_during_day = \"sleepy\")#提取睡眠呼吸暂停相关的数据\n> #将原来的变量值进行重编码👇\n> # Recode(d$apnea) \n> d$apnea <- Recode(d$apnea,\n+   \"sleep apnea::yes\", \n+   \"NA::\",\n+   to.numeric = FALSE)\n> # Recode(d$stop_breathing)\n> d$stop_breathing <- Recode(d$stop_breathing,\n+   \"never::no\", \n+   \"frequently (5 or more nights/week)::yes\", \n+   \"rarely (1-2 nights/week)::no\", \n+   \"occasionally (3-4 nights/week)::yes\", \n+   \"NA::\",\n+   to.numeric = FALSE)\n> # Recode(d$sleepy)\n> d$sleepy <- Recode(d$sleepy,\n+   \"rarely (1 time a month)::no\", \n+   \"never::no\", \n+   \"almost always (16-30 times a month)::yes\", \n+   \"sometimes (2-4 times a month)::yes\", \n+   \"often (5-15 times a month)::yes\", \n+   \"NA::\",\n+   to.numeric = FALSE)\n> d$osas <- paste0(d$apnea,\"~\",d$stop_breathing,\"~\",d$sleepy)#将三个指标合并在一起\n> # Recode(d$osas) #开始筛选诊断标准，三个中任意一个为yes就可以诊断为OSAS\n> d$osas <- Recode(d$osas,\n+   \"NA~no~no::no\", \n+   \"NA~no~yes::yes\", \n+   \"yes~no~no::yes\", \n+   \"yes~NA~yes::yes\", \n+   \"NA~yes~no::yes\", \n+   \"NA~NA~yes::yes\", \n+   \"yes~yes~yes::yes\", \n+   \"NA~yes~yes::yes\", \n+   \"NA~NA~no::no\", \n+   \"NA~no~NA::no\", \n+   \"yes~no~yes::yes\", \n+   \"yes~yes~no::yes\", \n+   \"NA~NA~NA::NA\", \n+   \"yes~NA~no::yes\",\n+   to.numeric = FALSE)\n\n3.也可以用于某种条件下进行分组. quant可以执行分位数的计算\n\n> d <- db_demo(years = 1999,sex = \"sex\",ageyr = \"age\",psu_strat = F) |> \n+   db_cbc(wbc_1000cells.ul = \"wbc\")\n> d <- drop_row(d,is.na(d$wbc))\n> #根据白细胞的均值分为2组\n> d <- add_col(d,\"wbc2\",\"high\",d$wbc > mean(d$wbc)) |> \n+   add_col(\"wbc2\",\"low\",d$wbc <= mean(d$wbc))\n> \n> #将白细胞按照四分位数分成4组，并且编码为Q1，Q2，Q3，Q4\n> # quant(d$wbc)\n> d$wbcQ <- quant(d$wbc, n = 4,Q = TRUE,round=3)#n=4即进行四分位数计算\n> d$wbcQ.median <- quant.median(d$wbc, n = 4,round=3)#计算每个四分位间距的中位数"
  },
  {
    "objectID": "nhanesR.html#数据提取汇总",
    "href": "nhanesR.html#数据提取汇总",
    "title": "nhanesR",
    "section": "数据提取汇总",
    "text": "数据提取汇总\n提取的数据可以进行叠加，例如db_demo() |> db_drtot()可以不断增加不同类型的数据\n\n提取人口学数据\n使用db_demo(),需要的列就指定为TRUE\n\n\n提取饮食数据\n使用db_drtot(), day= 可以指定是一天的饮食数据还是两天的饮食数据，默认是2天的数据。fun= 可以计算mean、sum、alone（2天的都分开显示），默认是sum。both2days表示是否只要2天都有的数据，默认为TRUE\n\n> x <- db_drtot(years = 2005,calcium_mg = T,Year = T,fun = \"alone\")\n> head(x)#alone显示2天的数据\n\n\n如果both2days为FALSE，则仅1天有数据的行也会显示\n\n> x <- db_drtot(years = 2005,calcium_mg = T,Year = T,both2days = F,fun = \"alone\")\n> head(x)\n\n\n\n\n提取生存数据\ndb_mort()用于提取生存数据，生存数据主要包括7列。\n\n> mort <- db_demo(years = 2005,ageyr = \"age\",sex = \"sex\",psu_strat = F) |> \n+   db_mort(years = 2005) #先人口学数据，然后添加上生存数据\n\n\n\n提取饮酒相关数据\n1.提取g/day\n\n> db_drtot(years=2005,alcohol_g = \"alcohol\",day = c(1,2),fun = \"mean\", both2days = F)\n\n2.提取drink/day的数据.注意不是cup/day\n\n> d <- db_fped(a_drinks = T,years = 2005)\n> d1 <- db_Alcohol.drinks(years = 2005)#这个是最准确的，drinks/day\n\n3.酒精使用程度分类\n\ncurrent heavey alcohol use\n≥3 drinks perday for female\n≥4 for male\nbinge drinking on 5 or more days per month\ncurrent moderate alcohol use\n≥2 drinks per day for female\n≥3 for male\nbinge drinking ≥ 2days per month\ncurrent mild alcohol use\nnot meet the above\n\n\n> t <- diag_alcohol.user(years = 2005,binge = T,Year = T)#可以修改mild,moderate，heavey的判断标准，可以设定是否有binge这个程度\n\n\n\n黄酮类化合物数据提取\n黄酮类化合物数据库Flavonoid。之前只有2007-2010的数据，2022年夏天出了2017-2018的数据。包含6种黄酮类的29种化合物的饮食摄入数据。day表示提取1天还是两天的数据，要么第一天，要么两天同时使用；当使用两天时，fun可以指定计算均值（mean）还是和（sum）；\n\n> fl <- db_flavonoids(Daidzein_mg = \"Daidzein\")\n\n\n\n重金属数据提取\n从pbcd数据中提取重金属相关的数据，使用db_PbCd()提取，数据从2005年开始，如铬、汞、锰等重金属。注意：当使用PbCd数据时，2013-2014和2015-2016两年，需要使用wtsh2yr权重，因为这两年12岁以上的参与者只有1/2的样本进行了检测，所以有一个单独的wtsh2yr，而1-11岁的wtsh2yr等同于MEC权重。所以涉及这两个year circle时使用特殊权重wtsh2yr，其余的circle使用MEC权重。dp_PbCd()中提供了权重weight = T即可自动提供权重(仅原始权重，合并权重按原方法计算）\n\n> x <- db_PbCd(years = 2013,blood_cadmium_ug.l = T,weight = T) |> \n+   drop_row(is.na(x$blood_cadmium_ug.l))"
  },
  {
    "objectID": "nhanesR.html#指标计算汇总",
    "href": "nhanesR.html#指标计算汇总",
    "title": "nhanesR",
    "section": "指标计算汇总",
    "text": "指标计算汇总\n\n健康饮食指数（Healthy eating index）\n健康饮食指数的介绍。HEI有两个版本2015和2010，2015是最新的版本，以符合2015-2020美国人膳食指南。算法包括简单算法和population ratio method，简单算法又包括Per day和Per person，per day就是在day = 1，Per person就是day=c(1,2), 对应method = “ssum”和”partio”.默认会给所有成分的评分，如果component = F就只给total score\n\n> x <- dex_HEI(years = 2011,version = 2015,method = \"ssum\",day = 1,dietary = \"tot\")\n\n\n\n咖啡数据提取\ndb_coffee(). 咖啡数据最好是在1999年以后进行。包含了是否添加咖啡因，是否加糖，是否加脂，加奶等，以及咖啡的种类，如卡布奇诺、摩卡、玛奇朵等等。 如何确定并识别咖啡数据？–使用的是FNDDs数据里的食物编码921开头的是coffee（用于写文章说明数据来源） 咖啡摄入的克数转化为杯数？–以6盎司为一杯\n\n> co <- db_coffee(years = 2003,\n+                 day = c(1,2), #要么提取第一天，要么提取两天的\n+                 fun = \"mean\", #默认取两天的均值\n+                 unit = \"g\") #g或者cup单位，默认是g\n\n\n\n饮食炎症指数的提取\n\n> di <- dex_DII(years = 2005)\n\n\n\n肾小球滤过率eGFR\ndex_eGFR()里提供了10种计算eGFR的方法，如Cockcroft_Gault,CKD_EPI_Scr,Schwartz等等，可以在mothod=里限定，默认是CKD_EPI_Scr。如果需要计算多种方法的eGFR，只需要method = c(,)。理论上来说推荐使用血肌酐计算滤过率，方法最推荐MDRD和CG方法\n\n> egf <- dex_eGFR(years = 2005,method = c(\"CKD_EPI_Scr\",\"BIS1_Scr\"))\n\n\n\n益生元、益生菌、合生元\n相关参考文献。FDA不监管益生菌，但是监管益生元（如乳果糖），所以如果只研究益生菌，只需要检索膳食补充剂的数据，而益生元的话需要检索药品，通过关键词来匹配是否含有益生元成分。\n\n> pr <- DSD(years = 2016,probiotic = T)"
  },
  {
    "objectID": "nhanesR.html#疾病诊断汇总",
    "href": "nhanesR.html#疾病诊断汇总",
    "title": "nhanesR",
    "section": "疾病诊断汇总",
    "text": "疾病诊断汇总\n\n代谢综合征\n使用diag_MetS() ，代谢综合征有两种计算方法，一种是ATP（美国的）和IDF（国际的）。不同年龄的计算公式不同，children and adolescent有单独的一套标准（modified ATP和IDF）。默认使用ATP标准。将分别计算>=16岁和10-16岁的诊断结果\n\n> x <- diag_MetS(years = 2015)\n\n\n\n\n高血压\ndiag_Hypertension().\n具体的高血压诊断标准：任意一个满足\n\n是否使用高血压药物\ndoctor told you or take drug\nbpx血压测量。分为mean和times，在method = 里设定\n\n\n> h <- diag_Hypertension(years = 2015,systolic = 140,diastolic = 90,n=3) #设定舒张压和收缩压阈值\n> h <- diag_Hypertension(years = 2015,method = \"mean\") #使用均值来诊断\n> h <- diag_Hypertension(years = 2015,method = \"times\",n=3) #使用3次测量来判断是否患有高血压\n\n\n\n高脂血症\n包块高甘油三酯血症、高胆固醇血症、和使用降脂药\n\n> d <- diag_Hyperlipidemia(years = 2015)"
  },
  {
    "objectID": "nhanesR.html#检索表",
    "href": "nhanesR.html#检索表",
    "title": "nhanesR",
    "section": "检索表",
    "text": "检索表\n\n> Left_Join(d1,d2,inspect = \"\")#合并，查看变量合并前后变化\n> db_demo()#人口学数据\n> db_cbc()#全血细胞类型的数据\n> dex_phenoAge()#生物学年龄\n> add_col()#添加列\n> select_row()#保留某些行,%in%, ==, !==, >=\n> dro_row(is.na())#去除某些行，如NA等\n> db_slq()#睡眠障碍相关数据\n> db_PbCd()#重金属相关数据\n> db_Alcohol.drinks()#提取酒精使用drinks/day的数据\n> db_drtot(alcohol_g = )#提取酒精使用g/day\n> diag_alcohol.user()#酒精使用程度"
  },
  {
    "objectID": "Python.html",
    "href": "Python.html",
    "title": "Python",
    "section": "",
    "text": "The reticulate package provides a comprehensive set of tools for interoperability between Python and R。官方文档 Cheatsheet\n\nlibrary(reticulate)\nuse_miniconda(condaenv = \"/Users/liulinhu/Library/r-miniconda\")#选择miniconda环境的python\nuse_condaenv(\"r-reticulate\")#选择conda环境的python\nminiconda_path()#显示miniconda安装地址\n\n可以使用miniconda来管理python库也可以用r-reticulate的环境来管理，选择use_miniconda或者use_condaenv来配置。安装python包可以用py_install()直接管理r-reticulate下的环境，或者使用conda installation\n\npy_install(\"pandas\")\npy_module_available(\"pandas\") #查看是否安装成功\nrepl_python()# 开始使用python，如果需要退出，输入exit\npd <- import(\"pandas\")#导入python库\nnp <- import(\"numpy\")\n\n\n\nreticulate提供了三种方式调用python\n\n直接在R markdown中用代码块区分：可打印python输出，包括matplotlib的图形输出，可以在r中访问python的对象（使用py$对象），反之用r.对象从python中访问r对象. 例如在python中用pandas导入数据，然后在R中用py对象进行绘图\n使用import()函数在R中调用python的模块 \nsource_python()和py_run_file()\n使用reticulate包中的source_python(‘py文件路径’)可以导入py文件中的变量，这样就可以在R代码块中使用外部变量。使用py_run_file()可以在R代码块中运行项目文件夹中的py文件"
  },
  {
    "objectID": "NHANES.html",
    "href": "NHANES.html",
    "title": "NHANES Tutorial",
    "section": "",
    "text": "收藏夹\n\n用R语言survey包进行权重计算\nnhanesR主网站\n\n网页版nhanesR\n\n账户95096026547614500\n密码48870131932211800\n\nRmarkdown如果要输出中文的pdf：先找到Ctex的模板，按照模板来调参数示意图.png\n不同年份的某些变量可能会发生变化，简写可能发生变化，但是要根据其实际含义来，可能是同一个东西。也有可能都是一个名字，但是不是同一个东西，例如血糖，可能都是血糖，但是有的是空腹血糖，有的是餐后2h血糖\n\n根据变量的实际意义来选择，不用过于在意变量的名字\n\n重要的功能：\n\nnhs_tsv()用于提取数据\nnhs_brief()用于查询上一步提取的tsv文件\nnhs_read()用于将提取出来的tsv挑选变量或重命名，解码含义等后生成新的数据集"
  }
]